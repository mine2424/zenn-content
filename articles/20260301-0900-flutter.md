---
title: "Flutterの状態管理を「誰が持つべきか」で考える"
emoji: "🎯"
type: "tech"
topics: ["flutter", "dart", "状態管理", "riverpod", "設計"]
published: false
---

## はじめに

Flutterを学び始めた人が最初につまずく壁のひとつが「状態管理」です。Riverpod、Bloc、Provider、GetX……選択肢が多すぎて、どれを選べばいいかわからないという声をよく聞きます。

しかし、どのライブラリを選ぶかよりも先に考えるべきことがあります。それは **「この状態は誰が持つべきか」** という問いです。

この問いに答えられると、ライブラリ選択は二次的な問題になります。本記事では、Flutterアプリにおける状態管理の「設計の考え方」を整理します。

---

## 状態の種類を分類する

まず、「状態」と一言で言っても、その性質はさまざまです。大きく分けると、以下のように整理できます。

### ローカル状態（UI状態）

特定のウィジェット内だけで完結する状態です。

- テキストフィールドのフォーカス状態
- アニメーションの進行状態
- ボトムシートの開閉状態
- チェックボックスのON/OFF

これらは**他のウィジェットに影響を与えない**状態です。`StatefulWidget` の `setState` か、`useState`（flutter_hooks）で十分に管理できます。

### 共有状態（アプリ状態）

複数のウィジェットやページをまたいで参照・更新される状態です。

- ログインユーザーの情報
- ショッピングカートの中身
- 選択中のテーマ（ライト/ダーク）
- サーバーから取得したデータのキャッシュ

これらは単一のウィジェット内に閉じ込めることができません。グローバルに参照可能な形で管理する必要があります。

---

## 「誰が持つか」という問いの本質

状態管理設計の核心は、**「この状態の変化に関心を持つのは誰か」** を特定することです。

関心を持つのが1つのウィジェットだけなら、そのウィジェットが持てばいい。複数のウィジェットが関心を持つなら、それらの共通の親、もしくはアプリ全体のレイヤーが持つべきです。

この考え方はReactのリフトアップ（State Lifting）と同じ原理で、Flutterでも有効です。

**誤り：何でもProviderやRiverpodに乗せる**

状態管理ライブラリの学習を始めると、「とにかくProviderに乗せれば管理できる」という過信が生まれることがあります。しかしローカル状態まで全てグローバルな状態管理に乗せると、コードが複雑になり、ウィジェットの再利用性も下がります。

**正しいアプローチ：適切なレイヤーに配置する**

```
アプリ全体：認証状態、テーマ、グローバル設定
ページ/機能単位：そのページが扱うデータの状態
ウィジェット単位：アニメーション、フォーカス、表示切り替え
```

この階層を意識することで、「どのレイヤーに置くべきか」という判断軸が生まれます。

---

## Riverpodの思想：依存グラフとしての状態

現在Flutterコミュニティで最も広く使われているRiverpodの設計思想は、**状態を依存グラフ（Dependency Graph）として捉える**ことにあります。

たとえば「商品リスト」は「選択中のカテゴリ」という状態に依存します。「選択中のカテゴリ」が変わると「商品リスト」は自動的に再計算されるべきです。

RiverpodのProviderはこの依存関係を宣言的に表現できます。あるProviderが別のProviderを参照（`ref.watch`）するだけで、依存関係が自動的に管理されます。

この設計の強みは、状態の変化が連鎖的かつ予測可能に伝播することです。「Aが変わったら、Aに依存するBも再計算される」という流れが明示的になるため、バグの追跡がしやすくなります。

---

## 非同期状態のパターン

実務的なアプリでは、APIからのデータ取得という非同期処理が必ず登場します。非同期状態には3つの状態があります。

- **Loading**：取得中
- **Data**：取得成功、データあり
- **Error**：取得失敗

Riverpodの `AsyncValue` はこの3状態をひとつの型で表現します。

```dart
final productsProvider = FutureProvider<List<Product>>((ref) async {
  return await ref.read(apiRepositoryProvider).fetchProducts();
});
```

UIでは `AsyncValue` をパターンマッチングで分岐します。

```dart
ref.watch(productsProvider).when(
  loading: () => const CircularProgressIndicator(),
  error: (e, _) => ErrorView(message: e.toString()),
  data: (products) => ProductListView(products: products),
);
```

この設計の良さは、**「ローディング状態の管理漏れ」「エラー状態のハンドリング忘れ」** という典型的なバグを型システムで防げることです。コンパイラが3状態全ての処理を書くことを強制してくれます。

---

## ビジネスロジックをUIから分離する

状態管理の設計で最終的に目指すべきことは、**ビジネスロジックをUIから完全に分離する**ことです。

ウィジェットは「状態を表示し、ユーザーの操作を伝える」役割だけを持つべきで、「何をすべきか」というロジックは含むべきではありません。

Riverpodの `Notifier` や `StateNotifier` がそのための受け皿になります。ユーザーがボタンを押したら `notifier.addToCart(product)` を呼ぶだけで、実際のロジック（バリデーション、API呼び出し、状態更新）はNotifier内に閉じ込められます。

この設計にすることで、

- ウィジェットのテストが容易になる（ロジックを気にしなくていい）
- ビジネスロジックのテストが容易になる（UIを気にしなくていい）
- ロジックの変更がUIに影響しない

という3つの恩恵を得られます。

---

## まとめ

Flutterの状態管理は、「どのライブラリを使うか」より「誰が何を持つべきか」を先に考えることが重要です。

- **ローカル状態は `setState` / `useState` で十分**
- **共有状態はレイヤーを意識して配置する**
- **依存関係は明示的に、宣言的に**
- **非同期の3状態（Loading/Data/Error）を型で保証する**
- **ビジネスロジックをUIから分離する**

状態管理の本質は技術選定ではなく、責任の分離です。「この状態は誰のものか」という問いを持つことが、スケールするFlutterアプリ設計への近道です。
