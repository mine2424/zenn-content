---
title: "Riverpodで状態管理を設計するとき、本当に考えるべきこと"
emoji: "🦋"
type: "tech"
topics: ["flutter", "riverpod", "dart", "statemanagement", "architecture"]
published: false
---

## はじめに

Flutterの状態管理は、長らく開発者の悩みの種だった。Provider、BLoC、GetX、Riverpod…数多くの選択肢が生まれ、「どれを使うべきか」という議論が絶えない。

その中でRiverpodは、Providerの後継として登場し、いまやFlutterコミュニティでの採用率が最も高い状態管理ライブラリのひとつになった。

しかし「Riverpodを使う」こと自体が目的になってしまうと、かえって複雑な設計に陥ることがある。この記事では、Riverpodの使い方よりも**状態管理を設計するときの考え方**を中心に整理していく。

## 「状態」とは何かを整理する

まず根本に立ち返ろう。Flutterアプリにおける「状態」とは何か。

状態とは、**ある時点でのアプリの「ありよう」**だ。ユーザーがログインしているか、リストに何が表示されているか、ボタンが押せる状態か──これらはすべて状態だ。

状態は大きく2種類に分けられる。

**ローカル状態**：あるウィジェット（またはその子）だけに関係する状態。テキストフィールドの入力値、アニメーションの進行度、ドロップダウンの開閉など。

**グローバル状態（共有状態）**：複数のウィジェット・画面にまたがって共有される状態。ログイン情報、カートの中身、テーマ設定など。

この区別が重要なのは、**ローカル状態はRiverpodを使わなくていい**からだ。`StatefulWidget`の`setState`や`ValueNotifier`で十分に管理できる。Riverpodで全状態を管理しようとすることが、設計を複雑にする一因だ。

## Providerの種類は「データの性質」で選ぶ

Riverpod 2.x以降では、コードジェネレータと組み合わせた`@riverpod`アノテーションが主流になりつつあるが、基本的なProviderの種類は変わらない。

各Providerの選び方は「そのデータが変化するか、変化するとしたら何をトリガーに変化するか」で決まる。

- **データが変化しない**（設定値、定数など）→ `Provider`
- **単純な状態を保持したい**（カウンター、フラグ）→ `StateProvider`
- **非同期でデータを取得する**（APIレスポンス）→ `FutureProvider`
- **リアルタイムストリーム**（Firestoreのリアルタイム更新）→ `StreamProvider`
- **複雑なビジネスロジックを持つ状態**→ `NotifierProvider`（旧`StateNotifierProvider`）

よくある間違いは、すべてを`NotifierProvider`で管理してしまうことだ。単純な非同期データは`FutureProvider`で十分だ。`NotifierProvider`が必要なのは、「データの変更方法」をメソッドとして定義する必要がある場合に限られる。

## 依存関係の設計：refを使う哲学

Riverpodの最大の特徴のひとつが、Provider同士が`ref.watch`で依存できることだ。

```dart
@riverpod
Future<List<Post>> userPosts(UserPostsRef ref) async {
  // ユーザー情報が変わったら自動で再フェッチされる
  final user = await ref.watch(currentUserProvider.future);
  return fetchPostsByUserId(user.id);
}
```

`userPosts`は`currentUser`に依存しており、ログインユーザーが変わると自動的に再計算される。このリアクティブな依存グラフがRiverpodの核心だ。

この設計のポイントは「**派生状態**」という考え方にある。`userPosts`は独立したデータではなく、`currentUser`から派生した状態だ。Riverpodでは、この派生関係を宣言的に記述できる。Excelのセル参照に似ている──あるセルの値が変わると、それに依存するセルが自動的に再計算される。

これを意識すると、「どのProviderが何に依存するか」という依存グラフを頭の中に描きながら設計できるようになる。

## 状態の「置き場所」と「スコープ」

Riverpodは全Providerがグローバルに利用できるが、だからといってすべてをグローバルに持つべきではない。

「この状態は誰が使うか」を考えると、自然とスコープが決まる。

- **アプリ全体で共有**→ ルートの`ProviderScope`にそのまま配置
- **特定の画面グループだけ**→ `ProviderScope`をサブツリーに挿入してオーバーライド
- **リスト項目ごとに独立した状態**→ `family`修飾子でパラメータ化

`family`修飾子は特に理解が浅いまま使われやすい。本質的には「同じ形の状態を複数インスタンス化する」ための仕組みだ。商品詳細画面を複数タブで開けるアプリで、それぞれのタブが独立した状態を持つような場合に使う。

## テスタビリティという視点

Riverpodが優れている点のひとつが、テストのしやすさだ。

ProviderをオーバーライドすることでDIが簡単にできる。テスト時にAPIクライアントをモックに差し替えるのは、`ProviderContainer`に`overrides`を渡すだけだ。

この設計は、Riverpodを使う理由の中でも特に実用的だ。「状態管理がテストしやすい設計になっている」ことは、長期的なコードのメンテナンス性に直結する。

テストを書くことを前提に設計することで、必然的に「ビジネスロジックがどこに置かれているか」が明確になる。ロジックがウィジェットの中に散乱していると、そもそもテストが書けない。Riverpodを使うことで、ロジックをNotifierやサービス層に切り出す習慣が自然に身につく。

## UI層との境界線を引く

最後に、最も重要な設計判断について述べる。それは「UIとロジックの境界をどこに引くか」だ。

ウィジェットが知って良いのは「どう表示するか」だけだ。「データをどこから取るか」「どのAPIを呼ぶか」「どういう条件で表示が変わるか」──これらはすべてProviderやNotifierの責任だ。

```dart
// ✗ ウィジェットがロジックを持ちすぎている
class ProductCard extends ConsumerWidget {
  Widget build(BuildContext context, WidgetRef ref) {
    final cart = ref.watch(cartProvider);
    final isInCart = cart.items.any((i) => i.productId == product.id);
    // ...条件分岐が続く
  }
}

// ✓ ロジックはProviderに集約する
class ProductCard extends ConsumerWidget {
  Widget build(BuildContext context, WidgetRef ref) {
    final isInCart = ref.watch(isProductInCartProvider(product.id));
    // ウィジェットはisInCartのtrue/falseだけを知っている
  }
}
```

この境界を守ると、ウィジェットはシンプルになり、ロジックはテストしやすくなり、変更に強くなる。

## まとめ：ツールより思想

Riverpodは強力なツールだが、道具である以上、使い方の哲学が重要だ。

- ローカル状態はRiverpodに頼らない
- Providerの種類はデータの性質で選ぶ
- 依存グラフを意識して設計する
- UIとロジックの境界を明確に引く

これらの原則はRiverpodに限らず、どんな状態管理ライブラリでも通用する設計の考え方だ。

「どのライブラリを使うか」ではなく「どう設計するか」を先に考える習慣が、長期間メンテナブルなFlutterアプリを生む。Riverpodはその設計を表現するための、現時点で最も優れた言語のひとつだ。
