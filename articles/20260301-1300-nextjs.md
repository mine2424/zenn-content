---
title: "Next.js App RouterにおけるStreaming UIの設計思想"
emoji: "🌊"
type: "tech"
topics: ["nextjs", "react", "streaming", "suspense", "appRouter"]
published: false
---

## はじめに

Next.js App RouterとReact Suspenseを組み合わせると、「Streaming UI」が実現できます。これは、ページ全体の読み込みを待たずに、準備できたコンポーネントから順次ユーザーに届ける仕組みです。

しかし、Streaming UIは単なる「速度改善のテクニック」ではありません。その背景にある設計思想を理解すると、コンポーネントの責務の分け方や、データフェッチの粒度についての考え方が変わります。この記事では、Streaming UIがなぜ良いのかという本質から考えてみます。

## ウォーターフォール問題から考える

従来のSSRでは、ページに必要なすべてのデータを取得してから、HTMLを生成してクライアントに送っていました。これは直感的にシンプルですが、「一番遅いリクエストがページ全体の速度を決める」という問題があります。

```
ユーザー情報取得: 50ms  ──────┐
投稿一覧取得:    200ms ───────┤→ すべて揃ったら → HTML生成 → 送信
おすすめ一覧取得: 300ms ──────┘
```

この場合、ユーザー情報は50msで取れているのに、おすすめ一覧を待って計300ms以上かかることになります。

Streaming UIの発想は、「準備できたものから送ればいい」というシンプルなものです。

```
ユーザー情報: 50ms後  → すぐ表示
投稿一覧:   200ms後  → できたら差し込む
おすすめ:   300ms後  → できたら差し込む
```

## Suspenseの役割を正確に理解する

Suspenseは「何かを待っている間、代わりのUIを表示する」仕組みです。

重要なのは、**Suspenseはコンポーネントの境界を定義する**という点です。Suspenseで囲まれたコンポーネント群は、「このまとまりはひとつの非同期単位」として扱われます。

```tsx
export default function Page() {
  return (
    <main>
      <UserHeader />  {/* 静的 or 高速 */}
      
      <Suspense fallback={<PostsSkeleton />}>
        <PostList />  {/* 少し遅い */}
      </Suspense>
      
      <Suspense fallback={<RecommendSkeleton />}>
        <RecommendSection />  {/* 一番遅い */}
      </Suspense>
    </main>
  );
}
```

`UserHeader`は静的なので即座に表示。`PostList`と`RecommendSection`はそれぞれ独立したSuspense境界で囲まれているため、できた方から順次表示されます。

## コンポーネント設計への影響

Streaming UIを真剣に考えると、コンポーネントの設計に影響が出てきます。

### データフェッチの責務を下に持たせる

従来の設計では、ページコンポーネント（またはgetServerSideProps）で必要なデータをすべて取得し、propsとして下位コンポーネントに渡すパターンが一般的でした。

Streaming UIでは、**各コンポーネントが自分に必要なデータを自分で取得する**設計が推奨されます。

```tsx
// PostList が自分でデータを取得する
async function PostList() {
  const posts = await fetchPosts(); // ここで待つ
  return <ul>{posts.map(post => <PostItem key={post.id} post={post} />)}</ul>;
}
```

これにより、PostListが遅くても他のコンポーネントの表示を妨げません。

### 「何を一緒に待つか」という設計判断

Suspenseの境界をどこに設けるかは、「ユーザー体験としてこれらは一緒に見えてほしいか、それとも個別に表示されてほしいか」という設計判断です。

たとえば、投稿タイトルと投稿本文は「一緒に出てきてほしい」ので同じSuspense内に置く。しかし、投稿本文とコメント欄は「コメントを待たずに本文を読んでほしい」ので別のSuspense境界で分ける。

こういった判断を意識的に行うことで、ユーザー体験を細かくコントロールできます。

## loading.tsxとの使い分け

App Routerには`loading.tsx`という仕組みもあります。これはページ全体のローディング状態を定義するものです。

- **`loading.tsx`**：ページ単位のローディング。ルート遷移時に表示される
- **`<Suspense>`**：コンポーネント単位のローディング。ページ内の部分的な非同期処理

ページ遷移のローディングは`loading.tsx`で対応し、ページ内の部分的な非同期処理は`<Suspense>`で対応する——この使い分けが基本です。

## エラー境界との組み合わせ

Suspense境界と同様に、`error.tsx`（エラー境界）も同じ粒度で考えると良いです。

「投稿一覧の取得に失敗したとき、ページ全体をエラーにするのか、投稿一覧の部分だけエラー表示にするのか」——これはUX設計として重要な判断です。

おすすめコンテンツが取得できなくてもページ全体は見せたい、というケースなら、そのコンポーネントに専用のエラー境界を設けます。クリティカルなデータが取れない場合はページ全体をエラーにする。こういった設計をSuspenseと合わせて考えることで、堅牢なアプリケーションになります。

## パフォーマンス指標への影響

Streaming UIはCore Web Vitalsの改善にも直結します。

- **TTFB（Time to First Byte）**: ページ全体のデータを待たずにHTMLの先頭部分を送れるため改善
- **FCP（First Contentful Paint）**: ヘッダーやナビゲーションなど高速な部分を先に表示できるため改善
- **LCP（Largest Contentful Paint）**: 重要なコンテンツをSuspense境界で適切に管理することで改善可能

ただし、何でもStreaming化すればいいわけではありません。非同期境界が増えすぎると、ページがちらちらと段階的に表示されてかえって不自然な体験になることもあります。バランスが大切です。

## おわりに

Streaming UIは「速くなる機能」というよりも、「コンポーネントの非同期境界を明示的に設計する思想」だと捉えると、より深く活用できます。

「このコンポーネントは何を待つか」「他のコンポーネントの表示を妨げていないか」——そういった問いをコンポーネント設計の中に組み込むことで、ユーザー体験と保守性の両方が向上します。App Routerを使っているなら、ぜひ意識してみてください。
