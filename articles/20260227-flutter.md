---
title: "Riverpodで「状態をどこに置くか」を迷わなくなるための考え方"
emoji: "🔷"
type: "tech"
topics: ["flutter", "dart", "riverpod", "statemanagement", "mobile"]
published: false
---

# Riverpodで「状態をどこに置くか」を迷わなくなるための考え方

Flutterアプリの開発を進めていると、必ず直面するのが「この状態、どこで管理すればいいのか？」という問いです。Provider? StatefulWidget? Riverpod? そしてRiverpodを使うとしても、`StateProvider`なのか`NotifierProvider`なのか、さらに`ref.watch`と`ref.read`の使い分けは——と、悩みは尽きません。

この記事では、Riverpodによる状態管理の「どこに置くか」問題を、技術的なAPIの説明ではなく**設計の考え方**から解決します。コードの前に思想を理解することが、迷わないための近道です。

---

## そもそも「状態」とは何か

Riverpodを語る前に、「状態（State）」の定義を整理します。

アプリケーションにおける状態とは、**UIのある瞬間のスナップショットを決定するデータ**のことです。「ユーザーがログインしているか」「カートに何が入っているか」「検索結果のリスト」「テキストフィールドの入力値」——これら全てが状態です。

状態には大きく2種類あります：

**ローカル状態（Ephemeral State）**
特定のウィジェット・画面にだけ関係する、短命な状態。テキストフィールドの入力中の値、アニメーションの途中状態、チェックボックスのオン/オフなど。

**グローバル状態（App State）**
複数の画面・コンポーネントにまたがる、アプリ全体で共有される状態。認証状態、ユーザープロフィール、ショッピングカートの中身など。

この分類が、「どこで状態を管理するか」を決める最初の判断軸になります。

---

## 原則：状態はできるだけ「近く」に置く

状態管理の基本原則は、**状態をそれを使うウィジェットのできるだけ近くに置く**ことです。

これはReactの「状態を引き上げる（Lifting State Up）」の考え方と同じです。状態を無条件にグローバルに置くと、どこで何が変わるか追いにくくなり、不要な再ビルドが起きやすくなります。

具体的な判断フロー：

1. **この状態は1つのウィジェットだけが使う？** → `StatefulWidget`か`StateProvider`をローカルで使う
2. **2〜3個の近いウィジェットが共有する？** → 共通の親ウィジェットに持たせる
3. **複数の画面をまたいで使われる？** → Riverpodのグローバルプロバイダーで管理する
4. **ユーザーセッション全体で必要？** → アプリ最上位のプロバイダーで管理する

「グローバルで管理したほうが楽だから全部Riverpodに入れよう」という発想は、長期的にコードの複雑さを増やします。

---

## Riverpodのプロバイダー選びの考え方

Riverpodには複数のプロバイダーが存在しますが、選択の基準は「状態がどれだけ複雑か」です。

### シンプルな値には `StateProvider`

単一の値（bool, int, String, enumなど）を管理するだけならStateProviderが最適です。

```dart
// ダークモードのオン/オフ
final darkModeProvider = StateProvider<bool>((ref) => false);

// 使う側
final isDark = ref.watch(darkModeProvider);
ref.read(darkModeProvider.notifier).state = !isDark;
```

StateProviderは「値の入れ物」として機能します。複雑なロジックは含まれておらず、ただ値を保持して変更を通知するだけです。

### 複雑なロジックには `NotifierProvider`

複数のフィールドを持つ状態や、状態変更に複雑なロジックが絡む場合はNotifierProviderを使います。

```dart
@riverpod
class CartNotifier extends _$CartNotifier {
  @override
  List<CartItem> build() => [];

  void addItem(Product product) {
    // 重複チェックや数量加算などのロジックを含む
    final existing = state.firstWhereOrNull((item) => item.id == product.id);
    if (existing != null) {
      state = state.map((item) =>
        item.id == product.id ? item.copyWith(quantity: item.quantity + 1) : item
      ).toList();
    } else {
      state = [...state, CartItem.fromProduct(product)];
    }
  }

  void removeItem(String itemId) {
    state = state.where((item) => item.id != itemId).toList();
  }
}
```

NotifierはViewModelに近い存在で、状態とそれを操作するメソッドをカプセル化します。ウィジェット側は「どうやって状態が変わるか」を知る必要がなく、`addItem()`を呼ぶだけで済みます。

### 非同期データには `AsyncNotifierProvider`

APIからのデータ取得など、非同期で状態を作る場合はAsyncNotifierProviderを使います。このプロバイダーは`AsyncValue<T>`型で状態を保持し、ローディング・成功・エラーの3状態を自動で管理します。

これにより、ウィジェット側では`when`メソッドを使って3状態を宣言的に描画できます。非同期処理特有の「ローディングフラグをいちいち管理する」煩わしさから解放されます。

---

## `ref.watch` vs `ref.read` ：「監視」と「読み取り」の違い

RiverpodのAPIで最も混乱しやすいのが `ref.watch` と `ref.read` の使い分けです。

### ref.watch：状態変化を「監視する」

`ref.watch` は状態を購読し、値が変わるたびにウィジェットを再ビルドします。UIに表示する値を取得するときは常に `ref.watch` を使います。

**buildメソッド内で使う**ことが原則です。

### ref.read：一度だけ「読み取る」

`ref.read` は現在の値を一度だけ読み取り、その後の変化は追いません。**イベントハンドラ（onPressed等）内で使う**のが典型的なケースです。

```dart
// ✅ 正しい使い方
ElevatedButton(
  onPressed: () {
    // ボタン押下時に一度だけNotifierのメソッドを呼ぶ
    ref.read(cartProvider.notifier).addItem(product);
  },
  child: Text('カートに追加'),
)
```

`onPressed` の中で `ref.watch` を使ってしまうと、状態変化のたびにハンドラが再実行されてしまい、予期しない動作を引き起こします。「ビルド = watch、アクション = read」という使い分けを覚えておくと迷いません。

---

## 依存関係を使って状態を組み合わせる

Riverpodの強力な機能の一つが、プロバイダー同士が依存できることです。

例えば「ログイン中のユーザーのカート」というプロバイダーは、「認証状態のプロバイダー」に依存します。

```dart
@riverpod
Future<Cart> userCart(Ref ref) async {
  // 認証状態を監視し、ユーザーが変わったら自動再実行
  final user = await ref.watch(currentUserProvider.future);
  return fetchCart(userId: user.id);
}
```

このように書くと、ユーザーがログアウトしてログインし直したとき、`userCart` は自動的にリセット・再取得されます。依存関係が自動で処理されるため、「ログイン状態が変わったときに手動でカートをリセットする」という命令的なコードが不要になります。

---

## まとめ：「どこに置くか」は「誰が使うか」で決まる

Riverpodの状態管理で迷わなくなるための考え方を整理します：

1. **ローカル状態はウィジェット近くで管理する** — 全てをグローバルにしない
2. **複雑さに応じてプロバイダーを選ぶ** — 単純な値はStateProvider、ロジックがあればNotifierProvider
3. **非同期はAsyncNotifierに任せる** — ローディング状態を自分で管理しない
4. **watchはbuildで、readはハンドラで** — 役割を意識して使い分ける
5. **依存関係はref.watchで表現する** — 手動同期のコードを書かない

Riverpodは「状態をどこにでも置ける自由」を与えてくれますが、その自由を上手に使うには「どこに置くべきか」の設計判断が重要です。APIを覚えるよりも先に、この設計の考え方を身につけることが、Riverpodを使いこなす近道です。
