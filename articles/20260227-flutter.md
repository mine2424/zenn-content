---
title: "Flutterのウィジェットライフサイクルを本当に理解する — initState から dispose まで"
emoji: "🦋"
type: "tech"
topics: ["flutter", "dart", "mobiledev"]
published: false
---

## 「なぜか動かない」の多くはライフサイクルの誤解から来る

Flutter を学び始めた人が詰まるポイントの一つに、ウィジェットのライフサイクルがあります。「`initState`でAPIを呼んだのにデータが表示されない」「`dispose`をいつ呼べばいいかわからない」「`setState`を呼んだら`initState`も再実行されると思っていた」——こういった誤解は珍しくありません。

ライフサイクルを正しく理解することは、Flutter 開発の根幹です。今回は`StatefulWidget`のライフサイクルを丁寧に整理します。

## StatefulWidget が二つのクラスに分かれている理由

Flutter を初めて触ると、`StatefulWidget`が`Widget`クラスと`State`クラスの二つに分かれていることに違和感を覚える人が多いです。なぜわざわざ分けるのでしょうか。

答えはパフォーマンスにあります。

Flutter ではウィジェットは非常に頻繁に再生成されます。`build`メソッドが呼ばれるたびに新しいウィジェットインスタンスが作られます。もし状態（State）もウィジェットと一緒に作り直されたら、画面を更新するたびにすべての状態が消えてしまいます。

そこで Flutter は、**軽量で使い捨てのウィジェット（設計図）** と、**生存し続けるState（状態）** を分離しました。ウィジェットは何度作り直されても、Stateは同じインスタンスが保持され続けます。この設計がパフォーマンスと状態保持の両立を可能にしています。

## ライフサイクルの流れ

`StatefulWidget`のライフサイクルは主に以下の順で進みます。

### createState

ウィジェットが最初にツリーに挿入されるとき、`createState`が呼ばれてStateオブジェクトが作られます。ここでは何かを初期化するのではなく、Stateのインスタンスを返すだけです。

### initState

Stateが作られた直後に一度だけ呼ばれます。ここが初期化処理の場所です。

「一度だけ」という点が重要です。`setState`を呼んで画面を更新しても、`initState`は再度呼ばれません。つまり、一回だけ行いたい処理——APIの初回呼び出し、アニメーションコントローラの初期化、リスナーの登録——はここに書きます。

注意点として、`initState`の時点ではまだウィジェットがツリーに完全に組み込まれていません。そのため、`context`を使った一部の操作は`initState`内では直接できず、代わりに`WidgetsBinding.instance.addPostFrameCallback`を使って最初のフレームが描画された後に実行する必要があります。

### didChangeDependencies

`initState`の直後に呼ばれ、その後は依存する`InheritedWidget`が変化するたびに呼ばれます。

`Theme.of(context)`や`MediaQuery.of(context)`のような、ツリーの上位から提供される値に依存した初期化が必要な場合は`didChangeDependencies`を使います。`initState`では`context`を使った依存取得が不安定なケースがあるためです。

### build

状態が変化するたびに呼ばれ、UIを構築します。何度でも呼ばれる可能性があるため、ここには副作用（API呼び出し、ファイル書き込みなど）を入れてはいけません。純粋に「現在の状態からUIを構築する」処理だけを書く場所です。

### didUpdateWidget

親ウィジェットが再ビルドされ、このウィジェットに渡される設定（プロパティ）が変わったときに呼ばれます。

例えば、外から渡される`userId`が変わったときに新しいユーザーのデータを取得し直す——という処理はここに書きます。`initState`は一度しか呼ばれないため、プロパティの変化に反応するには`didUpdateWidget`を使う必要があります。

### dispose

ウィジェットがツリーから取り除かれるときに呼ばれます。リソースの解放処理はここに書きます。

具体的には、`AnimationController`の`dispose()`、`TextEditingController`の`dispose()`、ストリームのサブスクリプションのキャンセル、リスナーの解除などです。これを怠るとメモリリークが発生します。

`dispose`で解放が必要なものは、対応する初期化が`initState`にあります。「`initState`で何かを作ったら、`dispose`で必ず解放する」という対応関係を意識することが大切です。

## よくある誤解と正しい理解

**誤解: setStateを呼ぶとinitStateが再実行される**

`setState`はUIの再ビルド（`build`の再実行）を引き起こすだけです。`initState`は再実行されません。これを知らないと「毎回APIを呼び直すためにinitStateに書く」という間違いが起きます。

**誤解: disposeを呼ばなくてもGCがやってくれる**

Dartのガベージコレクタはメモリを解放しますが、ストリームのサブスクリプションやアニメーションコントローラのような外部リソースへの参照は自動的にキャンセルされません。`dispose`を書かないと、画面を離れた後もリソースが動き続けるメモリリークが発生します。

**誤解: buildは一度だけ実行される**

`build`は非常に頻繁に呼ばれます。`setState`のたびはもちろん、親ウィジェットが再ビルドされると子の`build`も呼ばれます。だからこそ`const`ウィジェットが重要で、不変なウィジェットは`const`にすることでFlutterが再ビルドをスキップできるようになります。

## ライフサイクルを意識した設計

ライフサイクルを正しく理解すると、「どこに何を書くか」の判断が明確になります。

- 一度だけ行う初期化 → `initState`
- 依存するコンテキストが必要な初期化 → `didChangeDependencies`
- プロパティの変化への対応 → `didUpdateWidget`
- UIの構築のみ（副作用なし） → `build`
- リソースの解放 → `dispose`

この対応関係を押さえることで、「なぜか動かない」「なぜかリークする」という問題のほとんどは未然に防げます。

ライフサイクルは Flutter の基礎であり、状態管理ライブラリを使うようになってもその背後でこの仕組みは動き続けています。しっかり理解した上で先に進むことが、Flutter エンジニアとしての土台を作ります。
