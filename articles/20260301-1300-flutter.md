---
title: "Flutterのウィジェットツリーとリビルドを正しく理解する"
emoji: "🎪"
type: "tech"
topics: ["flutter", "dart", "widget", "パフォーマンス", "状態管理"]
published: false
---

## はじめに

Flutterを使い始めて少し経つと、「なぜかUIの更新が遅い」「意図しない場所まで再描画されている」という問題に直面することがあります。こういった問題の多くは、Flutterのウィジェットツリーとリビルドの仕組みを正確に理解していないことに起因しています。

この記事では、Flutterがどのようにウィジェットツリーを管理し、どのタイミングでリビルドが起きるかを整理したうえで、不必要なリビルドを避けるための考え方を説明します。

## Flutterの三層構造を理解する

Flutterには、ウィジェット・エレメント・レンダーオブジェクトという三層構造があります。

- **Widget**: 設計図。軽量で不変（immutable）なオブジェクト
- **Element**: ウィジェットとレンダーオブジェクトをつなぐ中間層。状態を持つ
- **RenderObject**: 実際の描画・レイアウト計算を担うオブジェクト

Flutterではよく「ウィジェットは軽量なので多用して大丈夫」と言われますが、正確にはウィジェット（設計図）は軽量であり、実際に重い処理を担うRenderObjectは必要なときだけ更新されます。

リビルドとは、ウィジェットを再生成することですが、それによって必ずしもRenderObjectが再生成・再描画されるわけではありません。Flutterのエンジンが差分を検出して、変更が必要な部分だけレンダーオブジェクトを更新します。

## StatefulWidgetのsetStateが影響する範囲

`setState`を呼ぶと、そのStatefulWidgetとその**子孫のウィジェットすべて**がリビルドされます。

これは多くの初学者が思っている以上に広い範囲です。たとえば、ページ全体を管理するStatefulWidgetで`setState`を呼ぶと、そのページのすべてのウィジェットがリビルドされます。

```dart
class MyPage extends StatefulWidget { ... }

class _MyPageState extends State<MyPage> {
  int _count = 0;
  
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // ↓ countが変わるたびにこれも再生成される（不要）
        const HeavyStaticWidget(),
        Text('Count: $_count'),
        ElevatedButton(
          onPressed: () => setState(() => _count++),
          child: const Text('Increment'),
        ),
      ],
    );
  }
}
```

`HeavyStaticWidget`は`_count`に関係ないのに、`setState`のたびに再生成されます。`const`を付けることで、Dartコンパイラがこのウィジェットをキャッシュし、再生成を防げます。

## constの力を正確に理解する

`const`ウィジェットは、コンパイル時に定数として確定し、同じインスタンスが再利用されます。Flutterのエレメントツリーは「同じウィジェットインスタンスなら更新不要」と判断するため、リビルドをスキップします。

```dart
// ❌ 毎回新しいインスタンスが生成される
child: Text('Fixed Text'),

// ✅ 同じインスタンスが再利用される
child: const Text('Fixed Text'),
```

動的な値を含むウィジェットには使えませんが、静的なアイコン、ラベル、装飾的なウィジェットには積極的に`const`を付けましょう。Flutter Analyzerが`const`を付けられる箇所を教えてくれるので、活用してください。

## ウィジェットを小さく分割する意義

「リビルドの範囲を狭くする」ために有効な手段が、ウィジェットを小さなStatefulWidget/StatelessWidgetに分割することです。

状態を変えたいコンポーネントだけをStatefulWidgetとして切り出し、その状態に関係のない部分は外に置く——これにより、状態が変わったときのリビルドが最小範囲で済みます。

```dart
// カウンター部分だけを独立したウィジェットに
class CounterWidget extends StatefulWidget {
  const CounterWidget({super.key});
  @override
  State<CounterWidget> createState() => _CounterWidgetState();
}

class _CounterWidgetState extends State<CounterWidget> {
  int _count = 0;
  
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Count: $_count'),
        ElevatedButton(
          onPressed: () => setState(() => _count++),
          child: const Text('Increment'),
        ),
      ],
    );
  }
}
```

これにより、カウンターが変わっても、その外側のウィジェットはリビルドされません。

## 状態管理ライブラリとリビルドの粒度

RiverpodやBlocといった状態管理ライブラリも、本質的には「どの範囲をリビルドするか」を制御するための仕組みです。

たとえばRiverpodの`Consumer`ウィジェットや`ref.watch`は、「このウィジェットはこのProviderの値を参照していて、値が変わったらこのウィジェットだけリビルドする」という宣言です。

```dart
class UserNameWidget extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final userName = ref.watch(userNameProvider); // この値が変わったときだけリビルド
    return Text(userName);
  }
}
```

状態管理の選択は「データをどう管理するか」という観点で語られることが多いですが、「リビルドの粒度をどう制御するか」という観点でも理解しておくと、パフォーマンス問題へのアプローチが変わります。

## DevToolsでリビルドを可視化する

FlutterのDevTools（Widget Inspector）には、リビルドされたウィジェットをハイライト表示する機能があります。実際に動かしながら「どのウィジェットがリビルドされているか」を目で見ることが、最も確実な最適化への道です。

予想外のウィジェットが頻繁にリビルドされていたら、それは設計を見直すサインです。

## おわりに

Flutterのリビルドは「悪いもの」ではありません。UIの更新はリビルドによって行われるのですから、必要なリビルドは必要です。問題は「不必要なリビルド」であり、それを減らすためには、ウィジェットツリーとリビルドの仕組みを理解したうえで意図的に設計することが必要です。

`const`を積極的に使う、状態を小さなウィジェットに閉じ込める、DevToolsで実際に確認する——この三つを習慣にするだけで、Flutterアプリのパフォーマンスは着実に改善されます。
