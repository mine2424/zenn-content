---
title: "Next.js App Routerにおけるデータフェッチの設計思想を理解する"
emoji: "🌊"
type: "tech"
topics: ["nextjs", "approuter", "react", "servercomponents"]
published: false
---

## はじめに

Next.js App Router の登場によって、データフェッチの考え方が根本から変わりました。Pages Router時代の `getServerSideProps` や `getStaticProps` に慣れた開発者にとって、App RouterのServer Componentsでのデータ取得は「どこでフェッチしてもいい」という自由度の高さが、かえって設計の迷いを生むことがあります。

この記事では、App Routerのデータフェッチがどのような思想に基づいているのかを理解し、「なぜそう書くのか」を説明できる設計力を養うことを目指します。

---

## Pages RouterからApp Routerへ：思想の転換

Pages Routerでは、データフェッチはページ単位で行われていました。`getServerSideProps` はページ全体のデータをまとめて取得し、それをコンポーネントにpropsとして流す。データの責任はページにあり、コンポーネントは受け取ったデータを表示する側に徹していました。

App RouterのServer Componentsでは、この責任の所在が変わります。**各コンポーネントが自分に必要なデータを自分でフェッチできる**という設計になっています。

これは一見シンプルな変化ですが、設計の思想としては大きな転換です。「データを取って配る（トップダウン）」から「必要な場所で必要なデータを取る（分散・コンポーネントローカル）」へのシフトです。

---

## なぜコンポーネントがフェッチするのか

コンポーネント内でデータをフェッチするアプローチには、いくつかの明確なメリットがあります。

### データとUIの共置

コンポーネントは「このデータを使ってこのUIを描く」という責務を持ちます。そのデータをフェッチするコードも同じコンポーネントに置けば、変更が局所化されます。「このAPIのレスポンスを変えたら、どのコンポーネントが影響を受けるか」が明確になります。

### ウォーターフォールの回避

Pages Routerでは、ページが必要なすべてのデータをトップレベルでまとめてフェッチしていました。そのため、コンポーネント間に依存関係がないデータも直列で取得されることがありました。

Server Componentsでは、並列にレンダリングできるコンポーネントは並列にフェッチされます。Reactのサスペンスと組み合わせることで、「準備できたコンポーネントから順に表示する」という細かい制御が可能になります。

### ストリーミングとの親和性

App RouterはHTTPストリーミングに対応しています。遅いデータソースに依存するコンポーネントが存在しても、他のコンポーネントのレンダリングをブロックしません。Suspenseバウンダリで包んだコンポーネントはデータが揃い次第クライアントに流れていきます。

これはユーザー体験の改善に直結します。すべてのデータが揃うまで真っ白な画面を見せるのではなく、準備できた部分から順に表示できるのです。

---

## リクエストのメモ化という仕組み

「コンポーネントがそれぞれフェッチする」という設計では、同じAPIに対する重複リクエストが心配になります。親コンポーネントと子コンポーネントが同じエンドポイントを呼んでいたら、2回リクエストが走るのでは？という疑問です。

Next.jsはこれを **fetch のメモ化** で解決しています。同一のレンダリングサイクル内で同じURLへの `fetch` が複数回呼ばれても、実際のネットワークリクエストは1回だけ実行されます。

```typescript
// UserProfile コンポーネント
async function UserProfile({ userId }: { userId: string }) {
  const user = await fetch(`/api/users/${userId}`).then(r => r.json());
  return <div>{user.name}</div>;
}

// UserActivity コンポーネント（同じAPIを呼ぶ）
async function UserActivity({ userId }: { userId: string }) {
  const user = await fetch(`/api/users/${userId}`).then(r => r.json());
  return <div>{user.lastActive}</div>;
}
```

上記のように2つのコンポーネントが同じURLをフェッチしていても、Next.jsのメモ化により実際のリクエストは1回です。これにより、「コンポーネントが自分の必要なデータを自分でフェッチする」という設計を、パフォーマンスを犠牲にせずに実現できます。

---

## キャッシュ戦略をどう設計するか

App Routerのデータフェッチで最も重要な設計判断の1つが、キャッシュ戦略です。

### 静的 vs 動的

デフォルトでは、App RouterはServerコンポーネントでの `fetch` をキャッシュします（静的レンダリング）。リクエストごとに最新データが必要な場合は、`{ cache: 'no-store' }` オプションを明示します。

一方、「1時間に1回だけ再検証する」という時間ベースのキャッシュには `{ next: { revalidate: 3600 } }` を使います。

重要なのは、**データの性質に合わせてキャッシュ戦略を選ぶ**という意識です。

- ユーザーのプロフィール → リクエストごとに最新（`no-store`）
- 商品カテゴリ一覧 → 1時間に1回程度更新（`revalidate: 3600`）
- ドキュメントページ → ビルド時に固定（デフォルトキャッシュ）

ページ全体に一律のキャッシュ戦略を適用するのではなく、コンポーネントごと・データソースごとに最適な戦略を選べることが、App Routerの強力な点です。

### On-Demand Revalidation

特定のイベント（管理者が記事を更新した、注文が入ったなど）をトリガーにキャッシュを無効化したい場合、`revalidatePath` や `revalidateTag` を使います。

これにより「基本的にキャッシュを使ってパフォーマンスを高めつつ、必要なときだけ最新化する」というハイブリッドな戦略が実現できます。

---

## クライアントコンポーネントとのデータ境界

Server Componentsでデータをフェッチし、Client Componentsにpropsとして渡す設計では、「どこをServerにしてどこをClientにするか」という境界の設計が重要です。

基本原則は**「できるだけサーバーサイドに留める」**です。データフェッチ、重い処理、セキュリティが必要な処理はサーバー側に。インタラクション（クリック、フォーム入力、リアルタイム更新）だけをクライアント側に切り出す。

この境界を正しく設計できると、JavaScriptのバンドルサイズが減り、初期表示が速くなり、SEOにも有利になります。

---

## まとめ

App Routerのデータフェッチ設計を理解するためのポイントを整理します。

- **コンポーネントが自分のデータを取る**：責任の共置により、変更の影響範囲が明確になる
- **メモ化で重複リクエストを防ぐ**：同一URL・同一サイクルなら1リクエストで済む
- **データの性質でキャッシュ戦略を選ぶ**：一律ではなく、データソースごとに最適解を選ぶ
- **ServerとClientの境界を設計する**：インタラクション以外はサーバー側に留める

App Routerのデータフェッチは「自由だから難しい」のではなく、「データとUIを近づける」という明確な思想を持っています。その思想を理解した上で設計することで、コードは読みやすく、パフォーマンスは高く、変更に強いアーキテクチャになります。
