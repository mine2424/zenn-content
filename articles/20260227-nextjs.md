---
title: "Server Componentsの「境界」をどう引くか：App Routerの設計思想を読み解く"
emoji: "⚛️"
type: "tech"
topics: ["nextjs", "react", "approuter", "servercomponents", "frontend"]
published: false
---

# Server Componentsの「境界」をどう引くか：App Routerの設計思想を読み解く

Next.js App Routerの登場によって、Reactのコンポーネント設計に大きな変化が訪れました。**React Server Components（RSC）**の導入により、コンポーネントは「サーバーで動くもの」と「クライアントで動くもの」に分かれ、開発者はその境界をどこに引くかを意識して設計する必要が生まれました。

しかし、「とりあえず `"use client"` を書いてエラーを消す」という対処療法的なアプローチでは、App Routerの恩恵を十分に受けられません。この記事では、Server ComponentsとClient Componentsの**設計上の境界をどう考えるべきか**を、思想レベルから掘り下げます。

---

## なぜコンポーネントに「場所」が生まれたのか

従来のReact（Pages Router時代）では、全てのコンポーネントはブラウザ上で動くことを前提としていました。サーバーサイドレンダリング（SSR）はあくまでHTMLの初期レンダリングのための仕組みであり、ハイドレーション後はクライアントが全てを管理します。

この設計の問題点は、**クライアントに不必要なコードが送られること**でした。例えば、マークダウンをHTMLに変換するライブラリをページに組み込んだとき、そのライブラリのコード全体がJavaScriptバンドルに含まれてユーザーのブラウザにダウンロードされます。しかし変換処理自体はサーバーでやればいい話であり、クライアントには完成したHTMLを渡せば十分です。

**React Server Componentsの核心的な発想は、「サーバーで完結できる処理はサーバーに閉じ込める」です。** これによりクライアントに送るJavaScriptを最小化し、より速いページロード・インタラクションを実現します。

---

## Server ComponentsとClient Componentsの本質的な違い

まず両者の特徴を明確に整理しましょう。

### Server Components（デフォルト）

- サーバーでのみ実行される
- `async/await` が使える（データフェッチを直接行える）
- `useState`, `useEffect`, イベントハンドラは使えない
- DBやファイルシステムに直接アクセスできる
- **JavaScriptバンドルに含まれない**（クライアントに送られない）

### Client Components（`"use client"` が必要）

- ブラウザで実行される（サーバーでも初期レンダリングはされる）
- `useState`, `useEffect`, ブラウザAPIが使える
- データフェッチはuseEffect等を経由する必要がある
- **JavaScriptバンドルに含まれる**（クライアントに送られる）

この違いを見ると、「できる限りServer Componentsを使う」方針が合理的であることが分かります。

---

## 境界を引く3つの原則

では実際に、どこにServer/Clientの境界を引けばよいのでしょうか。3つの原則で考えてみます。

### 原則1：インタラクションの有無で分ける

最もシンプルな判断基準は「ユーザーのインタラクションが必要か」です。

ボタンのクリック、フォームの入力、ホバー時のアニメーション、モーダルの開閉——これらは全てブラウザ上のイベントに依存するため、Client Componentsが必要です。

一方、ブログ記事の本文、商品一覧、ヘッダーのロゴ、静的なナビゲーションリンク——これらはインタラクションがなく、サーバーでレンダリングして送れば十分です。

**「このコンポーネントはユーザーが触るか？」を問うことが最初のステップです。**

### 原則2：境界はできるだけ葉（末端）に近づける

App Routerの設計でよくある失敗は、**インタラクティブな部分が1箇所あるだけで、その親コンポーネント全体に `"use client"` を付けてしまう**ことです。

例えば、商品詳細ページを考えます。ページには商品画像・説明文・価格（Server Componentsでよい）と、「カートに追加」ボタン（Client Componentが必要）があります。

このとき、ページ全体を `"use client"` にしてしまうのではなく、「カートに追加ボタン」コンポーネントだけを切り出してClient Componentにするのが正しい設計です。これにより、商品画像や説明文はServer Componentのまま保たれ、クライアントに送るJSを最小限にできます。

**「use client」の境界は、コンポーネントツリーの末端（葉）に寄せるほどパフォーマンスが最適化されます。**

### 原則3：データフェッチはServer Componentに集める

データをどこで取得するかも重要な設計上の判断です。

従来のPages RouterではgetServerSidePropsやgetStaticPropsでデータを取得し、コンポーネントにpropsとして渡す必要がありました。App Routerでは、**Server Component自身がasync/awaitで直接データを取得できます**。

```typescript
// app/products/page.tsx - Server Component
export default async function ProductsPage() {
  const products = await fetchProducts(); // DBやAPIに直接アクセス
  
  return (
    <div>
      {products.map(product => (
        <ProductCard key={product.id} product={product} />
      ))}
    </div>
  );
}
```

データフェッチをServer Componentに集約することで：
- APIキーやDBの接続情報がクライアントに漏れない
- ウォーターフォール（連鎖的なフェッチ）を防ぎやすい
- コンポーネント単位でデータの責任が明確になる

---

## よくあるアンチパターンと改善策

### アンチパターン1：全コンポーネントに `"use client"` を書く

エラーを消すための手っ取り早い対処として全部に付けてしまうと、Server Componentsの恩恵が完全に消えます。まず「本当にクライアントが必要か」を問い直すことが大切です。

### アンチパターン2：Server ComponentのpropsにEvent Handlerを渡す

Server ComponentはシリアライズされてクライアントのReactに渡されますが、**関数（イベントハンドラ）はシリアライズできません**。Server ComponentのpropsにonClickなどを渡そうとするとエラーになります。

コールバックが必要なときは、そのコンポーネント自体をClient Componentにするか、パターンを見直す必要があります。

### アンチパターン3：Context を全体に使う

React ContextはClient Component専用です。Server ComponentはContextを読み取れません。アプリ全体でContextを使いたい場合は、最上位のClient Componentにラップする必要がありますが、これはツリー全体をClientにする可能性があります。

Contextに頼らず、**Server Componentはpropsでデータを受け取り、必要最小限の箇所だけContextを使う**設計が理想です。

---

## Streaming と Suspense との連携

App RouterのもうひとつのキーコンセプトがStreamingです。Server Componentsと`<Suspense>`を組み合わせると、**ページの一部を後から段階的に送信（ストリーミング）**できます。

データ取得が遅いコンポーネントがあっても、他の部分は先に表示してローディング状態を見せながら、データが揃ったコンポーネントだけ後から差し込む——これにより、ページ全体がデータ待ちになる「ウォーターフォール体験」を解消できます。

境界を正しく引いてServer Componentsを活用することで、Streamingとの親和性も自然に高まります。

---

## まとめ：「責任の場所」を問い直す

App RouterとReact Server Componentsは、コンポーネントに「責任の場所」を与えます。この設計思想の本質は：

1. **インタラクションの有無**でServer/Clientを分ける
2. **境界は末端コンポーネント**に寄せる
3. **データフェッチはServerに集める**
4. **Contextや関数はClientの責任範囲**と心得る

`"use client"` の付け方一つで、アプリのパフォーマンスとセキュリティ特性が大きく変わります。「どこに線を引くか」を意識して設計することで、App Routerが本来持つ力を最大限に引き出せるようになります。
