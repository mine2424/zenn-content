---
title: "Next.js のキャッシュ戦略を正しく理解する — 何が・どこで・いつキャッシュされるのか"
emoji: "⚡"
type: "tech"
topics: ["nextjs", "react", "frontend", "webperformance"]
published: false
---

## 「なぜ更新が反映されないのか」の答えはキャッシュにある

Next.jsを使っていると、必ずぶつかる問題があります。「コンテンツを更新したのに画面に反映されない」「デプロイしたのに古いデータが表示される」——そのほとんどの原因はキャッシュです。

App Routerになってから、Next.jsのキャッシュは非常に多層的になりました。何がどこでキャッシュされているのかを把握していないと、デバッグに時間がかかったり、パフォーマンスを最大化できなかったりします。

今回はNext.jsのキャッシュ戦略を「何が」「どこで」「いつ」という観点で整理します。

## Next.jsには4層のキャッシュがある

App Routerには主に4つのキャッシュ層があります。それぞれが異なる目的と動作を持っています。

**1. Request Memoization**

同一リクエスト内で同じURLへの`fetch`を複数回呼んでも、実際のネットワークリクエストは1回だけになる仕組みです。React の render pass の中での重複リクエストを防ぎます。

コンポーネントをまたいで同じデータを`fetch`しても問題ないのはこのおかげです。Propsでデータを渡し回すより、各コンポーネントが必要なデータを直接`fetch`する設計が可能になります。

**2. Data Cache**

`fetch`の結果をサーバー上で永続化するキャッシュです。デプロイをまたいでも保持され、明示的に無効化しない限り保持され続けます。

デフォルトでは`fetch`の結果はキャッシュされます。`no-store`オプションをつけるとキャッシュしない。`revalidate`オプションで有効期限を設定できます。

**3. Full Route Cache**

ビルド時に静的レンダリングされたルートのHTMLとRSC Payloadをサーバーに保存するキャッシュです。リクエストのたびにレンダリングし直す必要がなくなります。

**4. Router Cache**

クライアント側に保持されるキャッシュで、訪問済みのルートとプリフェッチされたルートのRSC Payloadを保存します。ページ間の移動が高速になる理由はこれです。

## キャッシュをコントロールする手段

これだけ多層なキャッシュを持つNext.jsで、思い通りの動作をさせるためのコントロール手段を整理します。

### revalidateで有効期限を設定する

データの鮮度要件が「リアルタイムでなくていいが、古くなりすぎてもいけない」という場合は`revalidate`が使えます。

```typescript
// 60秒ごとに再取得
const data = await fetch('/api/posts', { next: { revalidate: 60 } });
```

ブログ記事のような「たまに更新されるコンテンツ」に適しています。

### revalidatePathとrevalidateTagでオンデマンド更新

コンテンツが更新されたタイミングでキャッシュを無効化したい場合は、Server Actionsや Route Handlers から`revalidatePath`や`revalidateTag`を呼び出します。

これにより「CMS で記事を更新したら即座にキャッシュを無効化する」という webhook 連携が作れます。キャッシュを持ちつつ、更新を即時反映できるという柔軟な設計が可能になります。

### no-storeでキャッシュを完全に無効化

ユーザーごとに異なるデータや、常に最新が必要なデータには`no-store`を使います。

```typescript
const data = await fetch('/api/user/dashboard', { cache: 'no-store' });
```

ただし`no-store`を多用するとサーバーの負荷が増えます。本当にリアルタイムが必要かどうかを考えることが重要です。

## Dynamic と Static の判断基準

App Routerのルートは「静的（Static）」か「動的（Dynamic）」かに分類されます。これがパフォーマンスに直結します。

静的レンダリングはビルド時に一度だけ実行され、結果がキャッシュされます。動的レンダリングはリクエストのたびに実行されます。

Next.jsは以下の条件を検出すると自動的に動的レンダリングに切り替えます。

- `cookies()`や`headers()`を使っている
- `searchParams`を参照している
- `no-store`の`fetch`がある

つまり、意図せずこれらを使うと静的最適化のメリットを失います。「本当にリクエスト時の情報が必要か」を常に意識することが、Next.jsのパフォーマンスを引き出す鍵です。

## キャッシュのデバッグ

キャッシュ関連の問題をデバッグするとき、最初にやるべきことは`NEXT_PRIVATE_DEBUG_CACHE=1`などの環境変数でキャッシュの動作をログに出すことです。何がキャッシュヒットして何がミスしているかが見えるだけで、問題の特定が格段に早くなります。

また`next dev`では意図的にキャッシュが無効化されていることに注意が必要です。開発環境でキャッシュをテストしたい場合は`next build && next start`で本番モードを使う必要があります。

## まとめ：キャッシュは「設定する」より「設計する」もの

Next.jsのキャッシュは強力ですが、理解せずに使うと意図しない動作の原因になります。

重要なのはキャッシュの「設定方法」を覚えることより、「どのデータがどのくらいの鮮度を必要とするか」を設計することです。その設計判断に基づいてキャッシュ戦略を選ぶ——これが Next.js のパフォーマンスを最大化する考え方です。

キャッシュを恐れず、でも正しく理解して使う。それだけでNext.jsアプリの品質は大きく変わります。
