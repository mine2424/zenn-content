---
title: "Flutterの状態管理を「どこに状態を置くか」という問いから考える"
emoji: "🗂️"
type: "tech"
topics: ["flutter", "dart", "状態管理", "riverpod"]
published: false
---

## はじめに

Flutterを学び始めた開発者が必ずぶつかる壁があります。それが「状態管理」の問題です。

Provider、Riverpod、Bloc、GetX、setState……選択肢が多すぎて何を選べばいいかわからない。そんな状況で「とりあえずRiverpodを使う」という選択をしても、どこに何の状態を置けばいいのかわからず、結果としてすべての状態をグローバルに管理してしまう——という経験をお持ちの方も多いのではないでしょうか。

この記事では、特定のライブラリの使い方ではなく、**「状態をどこに置くか」という根本的な問い**から状態管理を考える方法を整理します。ライブラリは後から選べますが、状態の置き場所の設計はアーキテクチャの根幹です。

---

## 「状態」とは何かを整理する

そもそも「状態（State）」とは何でしょうか。Flutterにおける状態とは、「UIの描画に影響を与える、変化し得るデータ」です。

ユーザーのログイン情報、取得したAPIのレスポンス、フォームの入力値、ボタンのローディング中フラグ——これらはすべて状態です。状態が変わるとUIが再描画されます。

重要なのは、状態には「**スコープ**」があるという点です。あるウィジェットにしか関係ない状態もあれば、アプリ全体で共有する必要がある状態もある。このスコープの違いを無視して設計すると、管理が複雑になります。

---

## 状態のスコープを3層で考える

状態のスコープを大きく3つに分けると、設計の判断がしやすくなります。

### 1. ローカル状態（ウィジェット内部）

特定のウィジェットのみが必要とする状態です。例えば、ドロップダウンメニューの開閉フラグ、アニメーションの進捗値、テキストフィールドのフォーカス状態などが該当します。

この種の状態は `StatefulWidget` の `setState` で管理するのが最もシンプルです。状態の影響範囲がウィジェットの境界内に収まっているなら、グローバルな状態管理ライブラリを使う必要はありません。シンプルさを選ぶことが正しい設計です。

### 2. 共有状態（親子・兄弟ウィジェット間）

複数のウィジェットが同じデータを参照する場合の状態です。例えば、フォームの複数画面にわたる入力データや、タブ間で共有されるフィルタ条件などが該当します。

この場合、状態を「共通の祖先ウィジェット」に持ち上げ（State Lifting）、子に渡す設計が基本です。ただし、ウィジェットツリーが深くなると「プロップドリリング」（無関係なウィジェットを経由してデータを渡す）が起きやすくなります。ここでInheritedWidgetやProviderが役立ちます。

### 3. グローバル状態（アプリ全体）

アプリのどこからでもアクセスできる必要がある状態です。ユーザーの認証状態、テーマ（ダーク/ライトモード）、通知数などが典型例です。

この層こそが、RiverpodやBlocのような状態管理ライブラリが最も力を発揮する領域です。しかし逆に言えば、すべての状態をここに置く必要はありません。

---

## 「なんでもグローバル」が引き起こす問題

状態管理ライブラリを使い始めると、シンプルなローカル状態もグローバルに管理してしまいがちです。「どこからでもアクセスできて便利」という感覚は理解できますが、これには落とし穴があります。

**テストが難しくなる**：グローバルな状態に依存するウィジェットは、テスト時にその状態をセットアップする必要があります。ローカル状態に収まっていれば、ウィジェット単体でテストできます。

**デバッグが複雑になる**：「この状態がいつ、どこで変わったか」を追うのが難しくなります。変更の発信元がアプリのどこにでもある可能性があるからです。

**再利用しにくくなる**：グローバル状態に依存するウィジェットは、その状態がある環境でしか動きません。他の画面や他のアプリへの移植が困難になります。

---

## 状態の置き場所を決める判断フロー

実際の開発では、以下のような問いを順番に立てることで、適切なスコープを選べます。

**1. この状態は1つのウィジェット内だけで完結するか？**
→ Yes → `setState` でOK。ライブラリ不要。

**2. 兄弟や子コンポーネントと共有する必要があるか？**
→ Yes → 共通の祖先に状態を持ち上げる。必要に応じてProviderで渡す。

**3. ページをまたいで、または離れた場所のウィジェットと共有が必要か？**
→ Yes → グローバル状態管理（Riverpod等）を使う。

**4. 状態はUIに依存するか、それともビジネスロジックに依存するか？**
→ ビジネスロジックに依存するなら、ViewModel/Notifierレイヤーに分離する。

このフローを習慣にするだけで、「とりあえずグローバル」という惰性を防げます。

---

## RiverpodのNotifierを例に「責務の分離」を考える

状態管理ライブラリを使う場合でも、「状態を持つこと」と「状態を変える手続き（ビジネスロジック）」を分離する意識が重要です。

```dart
@riverpod
class TodoList extends _$TodoList {
  @override
  List<Todo> build() => [];

  void add(String title) {
    state = [...state, Todo(title: title)];
  }

  void toggleComplete(String id) {
    state = state.map((todo) {
      return todo.id == id ? todo.copyWith(isCompleted: !todo.isCompleted) : todo;
    }).toList();
  }
}
```

このNotifierは「TodoリストというState」と「Todoを追加する・完了を切り替えるという操作」の両方を持っています。ウィジェットはこのNotifierを呼ぶだけで、ビジネスロジックを自分で持たない。

この分離により、ウィジェットはUIの描画に集中でき、NotifierはロジックのユニットテストができるようになりCallます。Flutterの状態管理における「関心の分離」の基本形です。

---

## まとめ

状態管理の本質は「どのライブラリを使うか」ではなく、「**状態をどこに置くか**」という設計の判断にあります。

- **スコープで分類する**：ローカル / 共有 / グローバルの3層で考える
- **ローカルは小さく保つ**：影響範囲が小さい状態は `setState` で十分
- **なんでもグローバルにしない**：テスタビリティ・デバッグ容易性が下がる
- **状態と操作を分離する**：ウィジェットはUI専念、ロジックはNotifier/ViewModelへ

状態管理の悩みは多くの場合、ライブラリの問題ではなく設計の問題です。「この状態は本当にグローバルに置く必要があるか？」という問いを常に持つことが、シンプルで保守性の高いFlutterアーキテクチャへの第一歩です。
