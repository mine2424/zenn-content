---
title: "Next.js App Routerで「データをどこで取得するか」を正しく考える"
emoji: "⚡"
type: "tech"
topics: ["nextjs", "approuter", "react", "servercomponents", "パフォーマンス"]
published: false
---

## はじめに

Next.js App Routerの登場により、Reactアプリケーションのデータフェッチの考え方は根本から変わりました。`useEffect` + `fetch` というクライアントサイドのパターンから、Server Componentsを活用したサーバーサイドでのデータ取得が主流になりつつあります。

しかしこの移行は単なる「書き方の変化」ではありません。**「どこでデータを取得するか」という設計判断そのものの変化**です。本記事では、App Routerにおけるデータフェッチの設計哲学を、「なぜそうするのか」という観点から整理します。

---

## 従来のパターンとその限界

Pages Routerの時代、データフェッチは大きく3つの方法で行われていました。

- `getStaticProps`：ビルド時にデータを取得
- `getServerSideProps`：リクエストごとにサーバーでデータを取得
- `useEffect` + `fetch`：クライアント側でマウント後に取得

これらは明確に使い分けられていましたが、コンポーネントの深い階層でデータが必要になったとき、「どこでフェッチしてpropsとして渡すか」という「Props Drilling問題」が発生しやすい構造でした。

データを必要とする場所と、取得できる場所が離れている——この構造的なギャップがコードを複雑にしていました。

---

## Server Componentsの本質：コロケーション

App RouterのServer Componentsが解決する最大の問題は、**「データを必要とする場所でデータを取得できる」** というコロケーション（co-location）の実現です。

```tsx
// app/products/[id]/page.tsx
async function ProductPage({ params }: { params: { id: string } }) {
  const product = await fetchProduct(params.id); // サーバーで直接取得
  return <ProductDetail product={product} />;
}
```

このコンポーネントはサーバーで実行されるため、データベースやAPIへの直接アクセスが可能です。そしてそのデータをpropsとして子コンポーネントに渡す必要もなく、**データが必要な場所で、データを取得できます**。

この設計の利点は、コンポーネントが「自分が必要なデータを自分で責任を持つ」という自己完結性を持てることです。

---

## 「どこで取得するか」の判断軸

Server Componentsによってデータフェッチの選択肢が増えた分、「どこで取得すべきか」の判断が重要になります。

### ① データが静的か、動的か

ビルド時に確定するデータ（サイトのコンフィグ、静的なコンテンツ）はキャッシュを活かし、`fetch` に `{ cache: 'force-cache' }` を設定します。一方、リクエストごとに変わるデータ（ユーザー固有の情報、在庫状況）には `{ cache: 'no-store' }` を使います。

この判断を適切に行うことで、不要なサーバー負荷を避け、パフォーマンスを最大化できます。

### ② データの影響範囲

あるデータが単一のコンポーネントにしか使われないなら、そのコンポーネント内でフェッチします。複数のコンポーネントにまたがるデータ（ログインユーザー情報など）は、共通の親コンポーネントまたは `layout.tsx` でフェッチし、Contextやpropsで共有します。

ただし「複数箇所で使うからlayoutでまとめてフェッチしよう」という発想は、必ずしも正解ではありません。App RouterはReactの `cache()` 関数によってサーバー側でのリクエスト重複排除が可能なため、**同じfetch呼び出しを複数のコンポーネントで行っても、実際のリクエストは1回だけ**になります。コロケーションを保ちながら、重複コストを排除できます。

### ③ ユーザーインタラクションが必要か

データの取得がユーザー操作（ボタンクリック、スクロールなど）をトリガーとする場合は、Client Componentで `useState` + `fetch`、またはSWRやTanStack Queryを使うアプローチが適しています。

---

## Streamingという考え方

App Routerが提供するもう一つの強力な概念が **Streaming** です。

従来のSSRでは、ページ全体のデータ取得が完了するまでHTMLは送信されませんでした。1つのAPIが遅ければ、ページ全体が遅くなります。

Streamingでは、`Suspense` を使って**準備ができたコンポーネントから順次クライアントへ送信**できます。

```tsx
<Suspense fallback={<ProductSkeleton />}>
  <ProductDetail id={id} />
</Suspense>
<Suspense fallback={<ReviewSkeleton />}>
  <ReviewList productId={id} />
</Suspense>
```

この設計では、商品詳細とレビューリストは独立して取得・描画されます。レビューの取得に時間がかかっても、商品詳細はすぐに表示されます。ユーザーは「何かが読み込まれている」という感覚よりも「コンテンツが順番に現れる」という体験を得ます。

Streamingを活かすためには、**ページを「取得速度の異なるデータブロック」として分解して考える**発想が必要です。

---

## 設計の落とし穴：「なんでもServer Component」

App Routerに慣れてくると、「Server Componentで書けばいい」という過信が生まれることがあります。しかしServer Componentには明確な制限があります。

- ブラウザAPIが使えない（`window`, `document` など）
- Reactのstateとeventが使えない
- クライアントサイドのライブラリとの互換性がない場合がある

インタラクティブなUIはClient Componentで書く必要があり、これは変わりません。重要なのは**「データの取得と表示のロジックはServer Componentに」「インタラクションはClient Componentに」** という責任の分離を意識することです。

---

## まとめ

App Routerにおけるデータフェッチの設計哲学は、次の考え方に集約できます。

- **コロケーション**：データは必要な場所で取得する
- **静的・動的の明示**：キャッシュ戦略をコード上で明確にする
- **Streamingで体験を分解する**：ページ全体を待たせない
- **Server/Clientの責任を分ける**：データと表示はサーバー、インタラクションはクライアント

「どこでデータを取得するか」という問いへの答えは、技術的な制約だけでなく、ユーザー体験とコードの保守性を両立させる設計判断です。App Routerはその判断を行う自由と責任を開発者に与えてくれます。
