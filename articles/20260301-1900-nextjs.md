---
title: "Next.js App Routerにおけるデータフェッチの設計思想を整理する"
emoji: "⚡"
type: "tech"
topics: ["nextjs", "approuter", "react", "servercomponents", "typescript"]
published: false
---

## はじめに

Next.js App Routerが登場して以来、データフェッチの設計は大きく変わった。Pages Routerの時代に身につけた`getServerSideProps`や`getStaticProps`の感覚を持ち込むと、App Routerの設計意図と噛み合わなくなることがある。

この記事では、App Routerにおけるデータフェッチの考え方を「なぜそうするのか」という設計思想のレベルから整理していく。実装パターンの暗記ではなく、思想の理解を目指す。

## Server Componentsがデータフェッチを変えた

App Routerの最大の変化は、Server Componentsがデフォルトになったことだ。

Server Componentsはサーバーサイドで実行され、その結果のHTMLだけがクライアントに送られる。つまり、**コンポーネント自体がデータフェッチの主体になれる**。

Pages Routerでは、データフェッチはページ単位で集約されていた。`getServerSideProps`で必要なデータを全部まとめて取得し、propsとして渡す。これは「ページがデータを管理する」という設計思想だ。

App Routerでは、各コンポーネントが自分に必要なデータを自分でフェッチできる。「コンポーネントがデータを管理する」という思想へのシフトだ。

```tsx
// Server Component でのデータフェッチ
async function UserProfile({ userId }: { userId: string }) {
  const user = await fetchUser(userId); // awaitが使える
  return <div>{user.name}</div>;
}
```

この変化は単なる構文糖衣ではない。コンポーネントの責任範囲がより明確になり、コロケーション（データとそれを使うUIの共存）が実現される。

## Request Memoizationという仕組み

「コンポーネントごとにフェッチするなら、同じデータを何度も取りに行かないのか？」という疑問はもっともだ。

Next.jsはこれを**Request Memoization**という仕組みで解決している。同一リクエスト内で同じURL・同じオプションの`fetch`が呼ばれた場合、2回目以降はキャッシュされた結果が返される。

つまり、複数のコンポーネントが同じAPIを`fetch`しても、実際のHTTPリクエストは1回だけ発生する。これにより「コンポーネントがデータを管理する」思想と「無駄なネットワーク通信をしない」効率性が両立される。

この仕組みを理解していないと、「なんとなくコンポーネントの上層で1箇所だけフェッチしてprops経由で渡す」というPages Router的な書き方に戻ってしまいがちだ。Request Memoizationがあるから、コロケーションを恐れなくていい。

## キャッシュ戦略の3層構造

App Routerのキャッシュは複雑に見えるが、**「どの時間軸でデータが変わるか」**という軸で整理すると理解しやすくなる。

### 静的データ（`force-cache`・デフォルト）

ビルド時に生成し、Vercelなどのエッジキャッシュに保存される。CDNレベルでのキャッシュが効くため、非常に高速だ。変更頻度が低いコンテンツ（ブログ記事、製品カタログなど）に向いている。

### 動的データ（`no-store`）

リクエストのたびにサーバーで新鮮なデータを取得する。ユーザー固有のデータや、秒単位で変わりうるデータに使う。Pages Routerの`getServerSideProps`に近い挙動だ。

### 時間ベースの再検証（`revalidate`）

「N秒間はキャッシュを使い、N秒後に再検証する」という中間的な選択肢だ。ニュースフィードや在庫情報など、リアルタイムでなくても良いが古くもあってはいけないデータに有効だ。

```tsx
// 60秒ごとに再検証
const res = await fetch('/api/products', { next: { revalidate: 60 } });
```

設計の判断基準は「このデータは何秒後に古くなると許容できないか」だ。この問いに答えると、自然にどのキャッシュ戦略を使うべきかが決まる。

## Suspenseとデータフェッチの組み合わせ

Server Componentsとデータフェッチが組み合わさると、もうひとつの重要な概念が浮かび上がる。Suspenseだ。

`loading.tsx`（またはSuspenseバウンダリ）を使うことで、**非同期でデータを取得しているコンポーネントのローディング状態をDeclarativeに表現**できる。

Pages Routerでは、ローディング状態は`useState`で`isLoading`フラグを管理し、条件分岐でスピナーを表示する命令的なアプローチが一般的だった。

App RouterのSuspenseでは、「このコンポーネントが準備できるまでの間、代わりにこれを表示する」という宣言的な記述になる。コンポーネントの非同期処理が完了したら、自動的に置き換えられる。

設計上の重要な判断は「Suspenseのバウンダリをどこに置くか」だ。ページ全体に1つ置くと、どれかひとつのフェッチが遅ければページ全体がローディングになる。コンポーネントごとに細かく置けば、個々のコンポーネントが独立してデータを読み込める。UX的にはどちらが好ましいかは、コンテンツの性質と重要度に依存する。

## Server ActionsとMutation設計

データの読み取りだけでなく、書き込み（Mutation）の設計も変わった。Server Actionsはサーバーサイドで実行される非同期関数で、フォームのサブミットやボタンのクリックに紐づけられる。

APIルートを経由せずに直接サーバーの処理を呼び出せるため、ボイラープレートが大幅に減る。ただし設計上の注意点もある。Server Actionsは「フォームのアクション」という用途に最適化されており、複雑なビジネスロジックを全部詰め込む場所ではない。ロジックは別のサービス層に切り出し、Server Actionsはそれを呼び出す薄いグルーコードとして保つのが堅牢な設計だ。

## まとめ：思想から設計へ

App Routerのデータフェッチを一言で表すなら、「**データをUIの近くに置く**」という思想だ。

- コンポーネントが自分のデータを自分でフェッチする（コロケーション）
- Request Memoizationで無駄なリクエストを排除する
- データの変更頻度に応じてキャッシュ戦略を選ぶ
- Suspenseでローディング状態を宣言的に扱う

これらは個別の技術的な選択肢ではなく、一貫した設計思想のもとに繋がっている。「なぜそうするのか」を理解していると、ドキュメントに載っていない判断も自然と下せるようになる。

App Routerの設計は最初とっつきにくく感じるかもしれないが、この思想を軸に読み解くと、各APIの位置づけが見えてくる。
